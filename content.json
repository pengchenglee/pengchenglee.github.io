[{"title":"angular","date":"2017-03-18T08:01:48.000Z","path":"2017/03/18/angular/","text":"框架和(库 vue react angular) 库 提供了很多方法，让我们来调用（主动调用） 框架 我们按照他的规范去写，人家调用我们（被动）（强约束） 框架的好处，提供完整的解决方案 MVC MVVM model 模型 数据 （从数据库中读取到的内容） view 视图 (我们看到的内容) controller 控制器 （控制将数据渲染到视图上） 当视图内容变化时调用控制器，控制器调用模型，渲染视图 MVVM model 数据 view 视图 viewModel 视图模型 适合单页（spa框架）面开发 下载angular 下载nodejs会提供一个叫npm的东西 node package manager 1npm install angular 通过npm来下载，别人上传上去的‘包’,默认安装到当前目录的node_modules文件夹中，如果上级目录有node_modules 会安装到上级中 ng-app 让angular用哪个模块来运行，会指定一个模块的名字，会产生一个$rootScope ng-model1ng-model=&apos;name&apos; 实现双向数据绑定的，当前作用域下没有变量，在当前作用域下声明，如果有变量，将name的值绑定给input标签，（数据影响视图）如果input中内容改变，会改变当前作用域上的（视图影响数据） ng-cloak123[ng-cloak]&#123; display:none&#125; 在所有闪烁的标签上增加ng-cloak属性 ng-bind 1.支持简单的运算 2.支持三元运算符 3.支持赋值操作 4.不会导致页面的闪烁 模块化1var app = angular.module(&apos;moduleName&apos;,[]); 控制器 使用控制器1&lt;div ng-controller=&quot;controlName&quot;&gt;&#123;&#123;a&#125;&#125;&lt;/div&gt; 123app.controller(&apos;controlName&apos;,function($scope)&#123; $scope.a = 1;&#125;)","tags":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/tags/框架/"}]},{"title":"this","date":"2017-03-15T09:46:46.000Z","path":"2017/03/15/this/","text":"1.this的第一种用法： 事件绑定函数中的this就是事件被触发的时候那个元素,其实也就是绑定给谁this就是谁 var div1 = document.getElementById(&apos;div1&apos;); div1.onclick = function (){ console.log(this);//div1 } 2.this的第二种用法: 函数中的this是谁，在定义的时候根本就不知道。在函数执行的时候，函数中的this(函数中)就是调用这个函数的行为主体,其实就是看函数前面的”.”，”.”前面是谁那么函数中的this就是谁。如果没有”.”那么this就是window function fn(){ console.log(this); } //console.log(window.fn); // 定义在全局作用域内的函数也是window的一个属性 var obj = { name : &apos;xxx&apos;, fn : fn }; obj.fn(); // this =&gt; obj fn(); // this =&gt; wind 3.this的第三种用法：自运行函数中的this永远是window (function (){ console.log(this); })(); var num = 10; var obj = { fn : (function (num){ // 这个自运行函数的作用域是不会被释放，因为返回值的匿名函数被obj.fn占用了 var num = 100; //这个100是不丢的。因为这个作用域没有被释放 console.log(this); return function (){ // 这个函数就是自运行函数的运行结果，运行结束后是要赋值给obj.fn当作属性值的 console.log(111); } })(num) }; console.log(obj.fn); //打印出来的是undefined =&gt; 说明在给对象赋值的过程中，如果属性值是一个自运行后函数，那么要等这个自运行函数的运行结果再赋值给属性 =&gt; 先运行后赋值 4.构造函数中的this是当前实例 5.call和apply都可以强制改变this 6.定时器中的this都是window 7.回调函数中的this一般也都是window","tags":[{"name":"常见this问题","slug":"常见this问题","permalink":"http://yoursite.com/tags/常见this问题/"}]},{"title":"git常用命令","date":"2017-03-14T08:13:28.000Z","path":"2017/03/14/git/","text":"mac的安装 先安装homebrew1brew install git 安装xcode，不用再安装git 配置邮箱和用户名 先查看配置 1git config --list 如果未配置name和邮箱 12git config --global user.name &apos;git用户名&apos;git config --global user.email &apos;git邮箱&apos; 创建文件夹1mkdir 文件夹的名字 改变目录1cd change directory 初始化git1git init .git文件存储着所有内容（提交，版本库，标签），初始化后会给一个分支默认叫master 创建文件1touch hello.js 查看文件内容1cat hello.js 像文件中写入内容 如果文件不存在则会创建文件 删除文件1rm &apos;文件名&apos; 编辑文件1vi hello.js 进入插入模式 i ,esc退出,:wq保存并且退出 查看状态1git status 增加暂存区1git add 没有增加前是红色 提交到历史区 将暂存区的内容提交到历史区1git commit -m &apos;提交成功&apos; 查看历史库日志1git log 比较不同 工作区和暂存区 1git diff 工作区和历史区 1git diff 分支的名字（master） 暂存区和历史区 1git diff --cached 搜索日志1git log --author/--grep 撤回add的内容1git reset HEAD 文件名 用暂存覆盖掉工作区1git checkout 文件名 版本回滚1git reset --hard 版本号 获取所有操作的版本号1git reflog 回到过去和未来 分支管理 查看所有分支 1git branch 创建分支 1git branch 分支名 切换分支 1git checkout dev 相当于把master复制了一份，提交到dev上master才看不到，相当于dev把100块钱放到自己家了，那master就无法看到了 删除分支1git branch -D 分支名 不能自己删自己 创建分支并且切换分支123git branch devgit checkout devgit checkout -b dev 合并分支 要切换到master身上来合并dev1git merge dev 比如说master上在slider里写了一个1，dev中slider写了2 从工作区直接提交到历史区 不支持首次提交，如果文件没有加到过缓存区中是不能使用这种方式的1git commit -a -m&apos;sliderdev&apos; 产生冲突 1.在dev分支中改变了slider.js改成了sliderdev,进行提交 2.在master分支中改变slider.js改成 slidermaster,进行提交 3.合并产生冲突，删除掉&gt;&gt;&gt;&gt;&gt; ====== &lt;&lt;&lt;&lt;&lt;&lt;再次提交","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]}]